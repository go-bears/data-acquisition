# Data conversion

## Goal

The goal of this  homework is to study the most common text-based data formats: `csv`, `xml`, `json`, and `html`. Parsing data files can be tricky, but generating them is easy and teaches you to speak in those languages. In this first homework, you will therefore be generating data in multiple formats but using standard Python libraries to read that data back in. The exception is that you will be parsing comma-separated value (CSV) files the hard way (i.e., yourself). 

You will create 5 Python programs:

* csv2html.py
* csv2xml.py
* csv2json.py
* xml2csv.py
* json2csv.py

which do the data conversions according to their names. A function call `getdata()` is provided for you in file `mycsv.py` (see below), either get the data from standard input or from the file mentioned on the command line. For example, the following command translates `foo.csv` to xml output.

```bash
$ python csv2xml.py foo.csv
<?xml version="1.0"?>
<file>
...
```

I have created a [starterkit zip file](https://github.com/parrt/data-acquisition/raw/master/hw/code/pipeline.zip) to get you started; or you can [browse the files](https://github.com/parrt/data-acquisition/tree/master/hw/code/pipeline).

I have created a [data directory](https://github.com/parrt/data-acquisition/tree/master/data) as well with data in various formats.

### (Optional) Translation pipeline

The idea of a pipeline is that you will be able to read in some data in csv format and pass it through a sequence of data conversions, ultimately getting it back to the original format:

<img src=figures/pipeline.png width=500>

From the commandline, it will look like this:

```bash
$ cat data.csv | \
  python csv2xml.py | \
  python xml2csv.py | \
  python csv2json.py | \
  python json2csv.py > samedata.csv
$ diff data.csv samedata.csv | wc
       0       0       0
```

The last  command just checks to make sure that there is no difference between the original file and the data after it's been pushed through the pipeline.

Because these programs read and write to standard input and standard output, we can mix and match them from the commandline to translate from one format to the other. For example, here's how to translate xml to json:

```bash
$ cat data.xml | \
  python xml2csv.py | \
  python csv2json.py > data.json
```

The programs also know how to read from a file if one is specified:

```bash
$ python xml2csv.py data.xml | python csv2json.py > data.json
```

It's also good idea to learn how to generate HTML for display in a browser, so we will create a CSV to HTML translator as well.

## Description

### Getting some initial stock data

Grab Apple's 35 year stock history using this URL and save it as `AAPL.csv`:

```
http://ichart.finance.yahoo.com/table.csv?s=AAPL
```

Or you can download [AAPL.csv](https://raw.githubusercontent.com/parrt/data-acquisition/master/data/AAPL.csv) from the course repo.

The file generated by that website is a CSV file with 8996 lines, which we can discover easily with `wc` from the commandline:
 
```bash
$ wc AAPL.csv
    8996    8997  583817 AAPL.csv
```

The first thing to notice is that there is a header row that describes the data in the various columns.
 
```bash
$ head AAPL.csv
Date,Open,High,Low,Close,Volume,Adj Close
2016-08-12,107.779999,108.440002,107.779999,108.18,18612300,108.18
2016-08-11,108.519997,108.93,107.849998,107.93,27484500,107.93
2016-08-10,108.709999,108.900002,107.760002,108.00,24008500,108.00
```

The data follows the header row, with one record per line. The key element of the CSV format is the separator, more specifically the venerable comma. It is the column or field separator that allows us to distinguish between the elements. For *m* columns, there are *m-1* separators. For *n* records, there are *n* lines (with possibly a header row in addition).

### Parsing simple CSV files

It's often best to start with a tiny input example before tackling a bigger data set. I made a small CSV file [t.csv](https://raw.githubusercontent.com/parrt/data-acquisition/master/data/t.csv):
 
```csv
when,a,b
2016-08-12,1.2,3
2016-08-13,3.99003,4.3
```

To parse that, we read the file and convert it to a list of lines and then we split each line on commas. That gives us a list of lists. Of course, the first line of the file is special; it is the header row. Let's get this first task out of the way then by completing the following code in `mycsv.py` (a library used by the other files):

```python
import sys

def getdata():
    if len(sys.argv)==1: # if no file given, read from stdin
        data = sys.stdin.read()
    else:
        f = open(sys.argv[1], "r")
        data = f.read()
        f.close()
    return data.strip()

def readcsv(data):
    """
    Read CSV with header from data string and return a header list
    containing a list of names and also return the list of lists
    containing the data.
    """
    ...
    return headers, data
```

Here is a sample Python test script, `test_readcsv.py`, that prints out the results of our `readcsv` function:

```python
headers, data = mycsv.readcsv(mycsv.getdata())
print headers
print data
```

Running with my simple test file, we'd generate this output:

```bash
$ python test_readcsv.py testdata.csv
['when', 'a', 'b']
[['2016-08-12', '1.2', '3'], ['2016-08-13', '3.99003', '4.3']]
```

Or, if you want to go back to csv format, you could use the following Python code:

```python
print "headers =", ','.join(headers)
for row in data:
    print ','.join(row)
```

###  Generating HTML

Now that we have `mycsv.py`, we can use it to read in CSV and dump some sample output in HTML format. This is useful for viewing large tables because the browser knows how to scroll. It's also an opportunity to learn some more HTML.

From our sample test data file, you need to generate the following HTML:

```html
<html>
<body>
<table>
<tr><th>when</th><th>a</th><th>b</th></tr>
<tr><td>2016-08-12</td><td>1.2</td><td>3.0</td></tr>
<tr><td>2016-08-13</td><td>3.99003</td><td>4.3</td></tr>
</table>
</body>
</html>
```

which looks like this in a browser:

<img src="figures/testdatahtml.png" width=170>

Of course our real data set is much bigger and the first part of it looks like this:

<img src="figures/datahtml.png" width=450>

In file `csv2html.py`, write a small script that reads in the CSV using `getdata()` and then prints out an HTML `table`.  As you did with your search engine project, you can use templates or just slap together strings in order to create the HTML.

The program should read from standard input or from a filename parameter to the script (this is handled automatically for you by `getdata()`:

```bash
$ python csv2html.py < testdata.csv > /tmp/t.html
$ python csv2html.py testdata.csv > /tmp/t.html
```

The `<` loads `testdata.csv` and shoves it into the standard input of the Python program. The `>` takes any standard output (from `print`s) and stores it in the indicated file, `/tmp/t.html`.

### Generating XML

One of the most common data formats you will run into is XML (HTML is like a specific kind of XML). There are begin and end tags that must match up. XML files also tend to start with information about the version: `<?xml version="1.0"?>`, so please put that in as well.

For the test file, the output should look like the following.

```xml
<?xml version="1.0"?>
<file>
  <headers>when,a,b</headers>
  <data>
    <record>
      <when>2016-08-12</when><a>1.2</a><b>3.0</b>
    </record>
    <record>
      <when>2016-08-13</when><a>3.99003</a><b>4.3</b>
    </record>
  </data>
</file>
```

From within the chrome browser, the real XML data from the AAPL history looks like this (although I think I have added an XML viewer plugin to the browser):
 
<img src="figures/dataxml.png" width=300>

*Please note that `Adj Close` is the proper name of the header, what you see in the `headers` tag. But, XML does not allow spaces in the name of the tag and so you must convert spaces to `_` characters as you see in the XML above.*

In file `csv2xml.py`, write a small script that reads in the CSV using `getdata()` and then prints out the data in XML. It also must specifically use the tags I have above: `file`, `headers`, `data`, `record`. Note that the `when` tag and the others within a record are not hardcoded: they depend on the headers from the CSV input

The program should read from standard input or from a filename parameter to the script (this is handled automatically for you by `getdata()`):

```bash
$ python csv2xml.py < testdata.csv > /tmp/t.xml
$ python csv2xml.py testdata.csv > /tmp/t.xml
```

The header names could have spaces in them, which makes them not legal XML tag names.  Header names like `Adj Close` should be converted to use underscores: `Adj_Close` in the generated XML.

### Generating JSON

JSON, a format typically used for the transmission of JavaScript data objects between browser and server, is also extremely popular. It is very similar to XML in that each data element is identified specifically. Naturally, JSON syntax looks quite different from XML but at an abstract level there very similar.

```json
{
  "headers":["when", "a", "b"],
  "data":[
    {
      "when":"2016-08-12", "a":"1.2", "b":"3"
    },
    {
      "when":"2016-08-13", "a":"3.99003", "b":"4.3"
    }
  ]
}
```

In file `csv2json.py`, write a small script that reads in the CSV using `getdata()` and then prints out the data in JSON. It also must specifically use the keys I have above: `headers`, `data`. Note that the `when` key and the others within a record are not hardcoded: they depend on the headers from the CSV input.

The program should read from standard input or from a filename parameter to the script (this is handled automatically for you by `getdata()`:

```bash
$ python csv2json.py < testdata.csv > /tmp/t.json
$ python csv2json.py testdata.csv > /tmp/t.json
```

### Reading XML Data

Parsing XML is beyond the scope of this class, but we still need to know how to use libraries that read this XML in. We're going to make a program called `xml2csv.py` that reads in XML and spits out CSV:
 
```bash
$ python xml2csv.py /tmp/t.xml
```

There are a number of XML libraries for Python, but the simplest one to use is [untangle](https://github.com/stchris/untangle). From some text, you can get a tree representation of the XML like this:

```python
xml = untangle.parse(xmltxt)
```

At this point, we need to know about the actual structure of the XML before we can pull data out. **This code will only work with XML structured like the XML output we generated above.** The root of the structure is the `file` tag so `xml.file` will get us that node in the tree. From there, you need to iterate over the `record` elements underneath the `data` tag. Pull out the individual values by their name such as `Date`.  Be careful how you fill in the CSV "table" for output: the order of the columns must be the order given in the headers tag.

The [Apple stock history in XML format](https://raw.githubusercontent.com/parrt/data-acquisition/master/data/AAPL.xml) looks like:

```xml
<?xml version="1.0"?>
<file>
  <headers>Date,Open,High,Low,Close,Volume,Adj Close</headers>
  <data>
    <record>
      <Date>2016-08-12</Date><Open>107.779999</Open><High>108.440002</High><Low>107.779999</Low><Close>108.18</Close><Volume>18612300</Volume><Adj_Close>108.18</Adj_Close>
    </record>
...
```

Notice that there are no spaces in the tag names but the `headers` tag includes header names with spaces like `Adj Close`. You will have to take this into consideration when looking for tags in the XML. Your output should look like the original AAPL.csv file that we worked with at the start of this project.

Another fun data set is [cd_catalog.xml](https://raw.githubusercontent.com/parrt/data-acquisition/master/data/cd_catalog.xml), which looks like:

```xml
<?xml version="1.0" encoding="ISO8859-1" ?>
<file>
<headers>TITLE,ARTIST,COUNTRY,COMPANY,PRICE,YEAR</headers>
  <data>
	  <record>
	    <TITLE>Empire Burlesque</TITLE>
	    <ARTIST>Bob Dylan</ARTIST>
	    <COUNTRY>USA</COUNTRY>
	    <COMPANY>Columbia</COMPANY>
	    <PRICE>10.90</PRICE>
	    <YEAR>1985</YEAR>
	  </record>
...
```

The converted data in CSV should look like:
 
```bash
TITLE,ARTIST,COUNTRY,COMPANY,PRICE,YEAR
Empire Burlesque,Bob Dylan,USA,Columbia,10.90,1985
Hide your heart,Bonnie Tylor,UK,CBS Records,9.90,1988
Greatest Hits,Dolly Parton,USA,RCA,9.90,1982
Still got the blues,Gary More,UK,Virgin redords,10.20,1990
Eros,Eros Ramazzotti,EU,BMG,9.90,1997
...
```

You can check your work with any of the XML files:
 
```bash
$ python xml2csv.py /tmp/t.xml | python csv2xml.py > /tmp/t2.xml
$ diff /tmp/t.xml /tmp/t2.xml
```

### Reading JSON data

Parsing JSON is beyond the scope of this class, but we still need to know how to use libraries that read this JSON in. We're going to make a program called `json2csv.py` that reads in JSON and spits out CSV:
 
```bash
$ python json2csv.py < /tmp/t.json
```

The standard `json` Python library works well. You can get a (possibly nested) dictionary from some JSON text with this:

```python
data = json.loads(jsontxt)
```

As with XML, we need to know the structure of the JSON "object" in order to pull data out of it. For example, you can pull out the headers like this:

```python
headers = data['headers']
```

Using the debugger, you can examine the various components of the `data` `dict`. I highly recommend you do that to orient yourself with the structure of the object.
 
You can check your work with:
 
```bash
$ python json2csv.py /tmp/t.json | python csv2json.py > /tmp/t2.json
$ diff /tmp/t.json /tmp/t2.json
```

## Deliverables

* mycsv.py
* csv2html.py
* csv2xml.py
* csv2json.py
* json2csv.py
* xml2csv.py
